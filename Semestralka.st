TestCase subclass: #BasicOperationsTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!BasicOperationsTests commentStamp: 'PavelErazim 12/26/2018 21:17' prior: 0!Normal operations, tests if basic operations like creating new object and accessing it works correctly.!!BasicOperationsTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initNormalRoot	|window|	window := FilmDatabaseWindow new.	window state loginPassed: 'normal'; 					passwordPassed: 'normal'.	window state buttonLogInAuth performAction.	self assert: window state class = NormalRootState.	^window! !!BasicOperationsTests methodsFor: 'tests'!testCorrectRole	| a n |	a := AdminUser		withNick: 'jarda-OOP'		withPassword: '123myjsmebratri!!'.	n := NormalUser		withNick: 'mates-OOP'		withPassword: '321aninahodu!!'.	self assert: a class equals: AdminUser.	self assert: n class equals: NormalUser	! !!BasicOperationsTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!setUpConnection	RealFilm setUpTestConnection.	FilmDatabaseWindow CleanAllRecords.	RealFilm ExamplesForTesting! !!BasicOperationsTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testEmptyFilmSingleton	| anotherEmptyMovie testdb |	testdb := FilmDatabaseWindow new.	[ anotherEmptyMovie := EmptyFilm new ]		on: Error		do: [ :e | self assert: e asString = 'Error: cannot create instance of singleton' ]! !!BasicOperationsTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testChangeUserData	| u |	u := AdminUser		withNick: 'jarda-OOP'		withPassword: '123myjsmebratri!!'.	u password: 'stupidPwd42'.	u nick: 'pepazdepa'.	self assert: u password = 'stupidPwd42'.	self assert: u nick = 'pepazdepa'! !TestCase subclass: #StatePatternTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!StatePatternTests commentStamp: 'PavelErazim 12/26/2018 15:57' prior: 0!Tests proper state pattern work.!!StatePatternTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initNormalRoot	|window|	window := FilmDatabaseWindow new.	window state loginPassed: 'normal'; 					passwordPassed: 'normal'.	window state buttonLogInAuth performAction.	self assert: window state class equals: NormalRootState.	^window! !!StatePatternTests methodsFor: 'tests' stamp: 'PavelErazim 1/5/2019 21:09'!testLoginNonexistingUser	| testdb |	self setUpConnection.	testdb := FilmDatabaseWindow new.	testdb state loginPassed: 'neexistujiciUzivatel'.	testdb state passwordPassed: 'nemaZadneHeslo123!!'.	testdb state logInAuth.	self assert: testdb state class = LogInState.! !!StatePatternTests methodsFor: 'tests' stamp: 'PavelErazim 1/5/2019 21:09'!testSignUpNewUser	| testdb |	self setUpConnection.	testdb := FilmDatabaseWindow new.	testdb state		loginPassed: 'vokurka';		passwordPassed: 'mrkev'.	testdb state buttonLogInAuth performAction.	self assert: testdb state class = LogInState.	testdb state buttonSignUp performAction.	self assert: testdb state class = SignUpState.	testdb state		loginPassed: 'vokurka';		passwordPassed: 'mrkev'.	testdb state buttonSignUp performAction.	testdb state buttonReturn performAction.	testdb state		loginPassed: 'vokurka';		passwordPassed: 'mrkev'.	testdb state buttonLogInAuth performAction.	self assert: testdb state class = NormalRootState.! !!StatePatternTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!setUpConnection	RealFilm setUpTestConnection.	FilmDatabaseWindow CleanAllRecords.	RealFilm ExamplesForTesting! !!StatePatternTests methodsFor: 'tests' stamp: 'PavelErazim 1/6/2019 13:08'!initAdminRoot	|window|	window := FilmDatabaseWindow new.	window state loginPassed: 'admin'; 					passwordPassed: 'admin'.	window state buttonLogInAuth performAction.	self assert: window state class equals: AdminRootState.	^window! !!StatePatternTests methodsFor: 'tests' stamp: 'PavelErazim 1/6/2019 14:14'!testConfirmState	| testdb userToDelete nick confirmText |	self setUpConnection.	testdb := self initAdminRoot.	testdb state buttonUsers performAction.	testdb state screen setSelectedIndex: 1.	nick := testdb state selectedNickOnScreen.	userToDelete := User selectOne: [ :each | each nick = nick asString ].	testdb state buttonDelete performAction.	confirmText := 'Are you sure you want to delete ' , userToDelete printInfo , '?'.	self assert: (testdb state class = ConfirmState and: testdb state text text = confirmText)! !StatePatternTests subclass: #AdminStatesTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!AdminStatesTests methodsFor: 'tests' stamp: 'PavelErazim 1/5/2019 21:09'!testSignOut	| window |	self setUpConnection.	window := self initAdminRoot.	self assert: window user nick = 'admin'.	self assert: window user password = 'admin'.	window state buttonSignOut performAction.	self assert: window state class = LogInState.	self assert: window user nick isNil.	self assert: window user password isNil! !!AdminStatesTests methodsFor: 'tests' stamp: 'PavelErazim 1/6/2019 13:01'!testDefaultStateAfterLogin	|window |	self setUpConnection.	window := self initAdminRoot.	self assert: window user nick = 'admin'.	self assert: window user password = 'admin'.	self assert: window state class = AdminRootState! !!AdminStatesTests methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initState: aState	|newWindow|	newWindow := FilmDatabaseWindow new: aState.	newWindow user: (User selectOne: [ :each | each nick = 'admin' & (each password = 'admin')  ]).	^newWindow! !AdminStatesTests subclass: #AddActorTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!AddActorTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testAddActorButtonReturn	|currentState window actorCnt|	self setUpConnection.	actorCnt := Actor selectAll size.	window := self initState: AddActorState.	currentState := window state.	currentState buttonReturn performAction.	self assert: Actor selectAll size = actorCnt.	self assert: window state class equals: AdminRootState.		 ! !!AddActorTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testAddActor	|currentState window actorCnt addedActor|	self setUpConnection.	addedActor := Actor new firstName: 'Test2'; surname: 'Actor'; born: 1000.	actorCnt := Actor selectAll size.	window := self initState: AddActorState.	currentState := window state.	currentState newPerson: addedActor.	currentState buttonAdd performAction.	self assert: Actor selectAll size = (actorCnt + 1).	self assert: (Actor selectOne: [ :each | each id = (actorCnt + 1) ]) = addedActor.	self assert: window state class equals: AddActorState.	self assert: (window state newPerson = addedActor) not.		! !AdminStatesTests subclass: #AddDirectorTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!AddDirectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testAddDirector	| currentState window directorCnt addedDirector |	self setUpConnection.	addedDirector := Director new		firstName: 'Test2';		surname: 'Director';		born: 1000.	directorCnt := Director selectAll size.	window := self initState: AddDirectorState.	currentState := window state.	currentState newPerson: addedDirector.	currentState buttonAdd performAction.	self assert: Director selectAll size = (directorCnt + 1).	self		assert: (Director selectOne: [ :each | each id = (directorCnt + 1) ]) = addedDirector.	self assert: window state class equals: AddDirectorState.	self assert: (window state newPerson = addedDirector) not.! !!AddDirectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testAddDirectorButtonReturn	|currentState window directorCnt|	self setUpConnection.	directorCnt := Director selectAll size.	window := self initState: AddDirectorState.	currentState := window state.	currentState buttonReturn performAction.	self assert: Director selectAll size = directorCnt.	self assert: window state class equals: AdminRootState.		 ! !AdminStatesTests subclass: #AddFilmTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!AddFilmTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testAddFilmWithActors	|currentState window filmCnt addedFilm actor|	self setUpConnection.	actor := Actor selectOne: [ :each | each id = 1 ].	addedFilm := RealFilm new name: 'Test';			director: (Director selectOne: [:each | each id = 1]);			genre: #horror.		filmCnt := RealFilm selectAll size.	window := self initState: AddFilmState.	currentState := window state.	currentState buttonAddActor performAction.	self assert: window state newFilm actors size = 0.	self assert: window state screen listItems = currentState screen listItems.	window state newFilm: addedFilm.	window state screen setSelectedIndex: 2.	window state buttonAddActor performAction.	window state buttonAdd performAction.		self assert: RealFilm selectAll size = (filmCnt + 1).	self assert: (RealFilm selectOne: [ :each | each id = (filmCnt + 1) ]) actors size = 1.	self assert: window state class equals: AddFilmState.		! !!AddFilmTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testAddFilm	|currentState window filmCnt addedFilm|	self setUpConnection.	addedFilm := RealFilm new name: 'Test';			director: (Director selectOne: [:each | each id = 1]);			genre: #horror.	filmCnt := RealFilm selectAll size.	window := self initState: AddFilmState.	currentState := window state.	currentState newFilm: addedFilm.	currentState buttonAdd performAction.	self assert: RealFilm selectAll size = (filmCnt + 1).	self assert: (RealFilm selectOne: [ :each | each id = (filmCnt + 1) ]) = addedFilm.	self assert: window state class equals: AddFilmState.	self assert: (window state newFilm = addedFilm) not.! !!AddFilmTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testAddFilmButtonReturn	|currentState window filmCnt |	self setUpConnection.	filmCnt := RealFilm selectAll size.	window := self initState: AddFilmState.	currentState := window state.	currentState buttonReturn performAction.	self assert: RealFilm selectAll size equals: filmCnt.	self assert: window state class equals: AdminRootState	! !StatePatternTests subclass: #ErrorStateTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!ErrorStateTests methodsFor: 'tests' stamp: 'PavelErazim 1/6/2019 13:10'!testErrorState	| testdb currentState |	self setUpConnection.	testdb := self initNormalRoot.		testdb state buttonViewFilm performAction.	testdb state buttonDirector performAction.	currentState := testdb state.	self assert:			(currentState class = ErrorState				and: currentState errorReceived class = ShowDirectorError)! !!ErrorStateTests methodsFor: 'tests' stamp: 'PavelErazim 1/6/2019 13:11'!testAddPersonWithMissingValueErrorState	| testdb addIncompleteActorState addIncompleteDirectorState |	self setUpConnection.	testdb := self initAdminRoot.	testdb state buttonAddActor performAction.	testdb state buttonAdd performAction.	addIncompleteActorState := testdb state.	self assert:			(addIncompleteActorState class = ErrorState				and: addIncompleteActorState errorReceived class = AddObjectWithMissingValuesError).	testdb state: AdminRootState.	testdb state buttonAddDirector performAction.	testdb state buttonAdd performAction.	addIncompleteDirectorState := testdb state.	self assert:			(addIncompleteActorState class = ErrorState				and: addIncompleteActorState errorReceived class = AddObjectWithMissingValuesError)! !!ErrorStateTests methodsFor: 'tests' stamp: 'PavelErazim 1/6/2019 13:10'!testAddFilmWithMissingValueErrorState	| testdb currentState |	self setUpConnection.	testdb := self initAdminRoot.	testdb state buttonAddFilm performAction.	testdb state buttonAdd performAction.	currentState := testdb state.	self assert:			(currentState class = ErrorState				and: currentState errorReceived class = AddObjectWithMissingValuesError).! !AdminStatesTests subclass: #ManageReviewTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!ManageReviewTests methodsFor: 'tests'!testManageReviewButtonReturn	|currentState window reviewCnt currentFilm|	self setUpConnection.	currentFilm := (RealFilm selectOne: [:each | each id = 1]).	ViewFilmState currentFilm: currentFilm.	ManageReviewState currentFilm: currentFilm.	window := self initState: ManageReviewState.	currentState := window state.	reviewCnt := currentFilm reviews size.	currentState buttonReturn performAction.	self assert: window state class equals: ViewFilmState.	self assert: reviewCnt = currentFilm reviews size.		 ! !!ManageReviewTests methodsFor: 'tests'!testDeleteNonSelectedReview	|currentState window reviewCnt currentFilm|	self setUpConnection.	currentFilm := (RealFilm selectOne: [:each | each id = 1]).	ViewFilmState currentFilm: currentFilm.	ManageReviewState currentFilm: currentFilm.	window := self initState: ManageReviewState.	currentState := window state.	reviewCnt := currentFilm reviews size.	currentState buttonDelete performAction.	self assert: window state class equals: ManageReviewState.	self assert: reviewCnt = currentFilm reviews size.	! !!ManageReviewTests methodsFor: 'tests'!testDeleteReview	|currentState window reviewCnt currentFilm|	self setUpConnection.	currentFilm := (RealFilm selectOne: [:each | each id = 1]).	ViewFilmState currentFilm: currentFilm.	ManageReviewState currentFilm: currentFilm.	window := self initState: ManageReviewState.	currentState := window state.	reviewCnt := currentFilm reviews size.	currentState screen setSelectedIndex: 1.	currentState buttonDelete performAction.	self assert: window state class equals: ManageReviewState.	self assert: (reviewCnt - 1) = currentFilm reviews size.		! !!ManageReviewTests methodsFor: 'tests'!testDeleteReviewFromEmptyFilm	|currentState window|	self setUpConnection.	ViewFilmState currentFilm: (AbstractFilm empty).	ManageReviewState currentFilm: ViewFilmState currentFilm.	window := self initState: ManageReviewState.	currentState := window state.	currentState buttonDelete performAction.	self assert: window state class  equals: ManageReviewState.! !AdminStatesTests subclass: #ManageUsersTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!ManageUsersTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testChangeRole	|window currentState userCnt|	self setUpConnection.	window := self initManageUserState.	userCnt := User selectAll size.	currentState := window state.	currentState screen setSelectedIndex: 1.	currentState buttonChangeRole performAction.	self assert: window state class = ManageUsersState.	self assert: (User selectOne: [ :each | each nick = 'normal' ]) class equals: AdminUser.	self assert: userCnt equals: User selectAll size.	window state screen setSelectedIndex: 1.	window state buttonChangeRole performAction.	self assert: window state class = ManageUsersState.	self assert: (User selectOne: [ :each | each nick = 'normal' ]) class equals: NormalUser.	self assert: userCnt equals: User selectAll size			! !!ManageUsersTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testDeleteNonSelectedReview	|currentState window userCnt|	self setUpConnection.	window := self initManageUserState.	currentState := window state.	userCnt := User selectAll size.	currentState buttonDelete performAction.	self assert: window state class = ManageUsersState.	self assert: userCnt = User selectAll size.		! !!ManageUsersTests methodsFor: 'tests' stamp: 'PavelErazim 1/5/2019 23:26'!testDeleteUser	|currentState window userCnt toDelete |	self setUpConnection.	window := self initManageUserState.	currentState := window state.	userCnt := User selectAll size.	currentState screen setSelectedIndex: 1.	toDelete := currentState screen selectedItem.	currentState buttonDelete performAction.	self assert: window state class = ConfirmState.	window state buttonNo performAction.	self assert: window state class = ManageUsersState .	self assert: userCnt = User selectAll size.	currentState buttonDelete performAction.	window state buttonYes performAction.	self assert: (userCnt - 1) = User selectAll size.	self assert: (User selectOne: [ :each | each nick = toDelete ]) isNil.! !!ManageUsersTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initManageUserState	|window|	window := self initAdminRoot.	window state buttonUsers performAction.	^window! !!ManageUsersTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testChangeRoleNotSelected	|window currentState userCnt|	self setUpConnection.	window := self initManageUserState.	userCnt := User selectAll size.	currentState := window state.	currentState buttonChangeRole performAction.	self assert: window state class = ManageUsersState.	self assert: (User selectOne: [ :each | each nick = 'normal' ]) class equals: NormalUser.	self assert: userCnt equals: User selectAll size.		! !!ManageUsersTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testManageReviewButtonReturn	|currentState window userCnt|	self setUpConnection.	window := self initManageUserState.	currentState := window state.	userCnt := User selectAll size.	currentState buttonReturn performAction.	self assert: window state class = AdminRootState.	self assert: userCnt = User selectAll size.	! !StatePatternTests subclass: #NormalUserStatesTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!NormalUserStatesTests methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initState: aState	| newWindow |	newWindow := FilmDatabaseWindow new: aState.	newWindow user: (User selectOne: [ :each | each nick = 'normal' & (each password = 'normal')  ]).	^ newWindow! !!NormalUserStatesTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testDefaultStateAfterLogin	|window|	self setUpConnection.	window := self initNormalRoot.	self assert: window user nick = 'normal'.	self assert: window user password = 'normal'! !!NormalUserStatesTests methodsFor: 'tests' stamp: 'PavelErazim 1/6/2019 13:30'!testAddReview	|testdb currentFilm reviewsSize |	self setUpConnection.	testdb := self initNormalRoot. 		testdb state screen setSelectedIndex: 1.	testdb state buttonViewFilm performAction.		currentFilm := testdb state class currentFilm.	testdb state buttonReview performAction.	 	reviewsSize := currentFilm reviews size.	self assert: testdb state class = ReviewsState.	self assert: currentFilm id equals: 1.	testdb state input accept: 'A very interesting review this is.'.	self assert: reviewsSize = (currentFilm reviews size - 1).	testdb state input accept: 'A very interesting review this is2.'.	testdb state input accept: 'A very interesting review this is3.'.		self assert: reviewsSize = (currentFilm reviews size - 3).	self assert: testdb state class = ReviewsState.! !NormalUserStatesTests subclass: #DirectorTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!DirectorTests methodsFor: 'tests'!testReturnToMovieButton	| currentState window |	self setUpConnection.	window := self initNormalRoot.	window state screen setSelectedIndex: 1.	window state buttonViewFilm performAction.	window state buttonDirector performAction.	self assert: window state class equals: DirectorState.	currentState := window state.	currentState buttonReturn performAction.	self assert: window state class equals: ViewFilmState.	self assert: window state class currentFilm equals: (RealFilm selectOne: [ :aFilm | aFilm id = 1 ])! !!DirectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testShowDirectorInfo	| currentState window |	self setUpConnection.	window := self initNormalRoot.	currentState := window state.	currentState screen setSelectedIndex: 1.	currentState buttonViewFilm performAction.	currentState := window state.	currentState buttonDirector performAction.	self assert: window state class equals: DirectorState.	self assert: window state class director equals: (RealFilm selectOne: [ :aFilm | aFilm id = 1 ]) director.! !AdminStatesTests subclass: #RemoveFilmTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!RemoveFilmTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testRemoveNonSelectedFilm	|window filmCnt|	self setUpConnection.	window := self initAdminRoot.	filmCnt := (RealFilm selectAll size).	window state buttonRemove performAction.	self assert: filmCnt = (RealFilm selectAll size).	self assert: window state class = AdminRootState.		! !!RemoveFilmTests methodsFor: 'tests' stamp: 'PavelErazim 1/6/2019 13:34'!testRemoveFilmAndConfirmState	| window filmCnt filmToRemove |	self setUpConnection.	window := self initAdminRoot.	filmCnt := RealFilm selectAll size.	window state screen setSelectedIndex: 1.	window state buttonRemove performAction.	self assert: window state class = ConfirmState.	window state buttonNo performAction.	self assert: filmCnt = (RealFilm selectAll size ).		window state screen setSelectedIndex: 1.	filmToRemove := window state selectedFilmOnScreen.	window state buttonRemove performAction.	window state buttonYes performAction.		self assert: filmCnt = (RealFilm selectAll size + 1).	self assert: (RealFilm selectOne: [ :each | each id = filmToRemove ]) isNil.	self assert: window state class = AdminRootState! !NormalUserStatesTests subclass: #SearchTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!SearchTests methodsFor: 'tests' stamp: 'PavelErazim 1/5/2019 21:48'!testSearchByGenreNonExisting	|window currentState|	self setUpConnection.	window := self initNormalRoot.	currentState := window state.	currentState buttonSearch byGenre click.	currentState inputText: 'nonexistinggenre'.	self assert: window state class equals: CollectionState.	self assert: window state screen listItems = (currentState genreCollection: 'nonexistinggenre')! !!SearchTests methodsFor: 'tests'!testViewByID	|window currentState|	self setUpConnection.	window := self initNormalRoot.	currentState := window state.	currentState buttonSearch byID click.	currentState inputText: 1.	self assert: window state class equals: ViewFilmState.	self assert: window state class currentFilm equals: (RealFilm selectOne: [ :aFilm | aFilm id = 1 ])! !!SearchTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!testSearchByGenre	|window currentState|	self setUpConnection.	window := self initNormalRoot.	currentState := window state.	currentState buttonSearch byGenre click.	currentState inputText: 'horror'.	currentState := window state.	self assert: currentState class equals: CollectionState.	self assert: currentState screen listItems = (currentState genreCollection: 'horror').	self assert: currentState screen listItems size = 1.! !!SearchTests methodsFor: 'tests'!testDefaultSearch	|window currentState|	self setUpConnection.	window := self initNormalRoot.	currentState := window state.	currentState inputText: 1.	self assert: window state class equals: ViewFilmState.	self assert: window state class currentFilm equals: (RealFilm selectOne: [ :aFilm | aFilm id = 1 ])! !!SearchTests methodsFor: 'tests'!testGhostTextChanging	|window currentState|	self setUpConnection.	window := self initNormalRoot.	currentState := window state.	self assert: currentState input ghostText equals: 'Type ID of a movie...'.	currentState buttonSearch byGenre click.	self assert: currentState input ghostText equals: 'Type genre of a movie...'.	currentState buttonSearch byID click.	self assert: currentState input ghostText equals: 'Type ID of a movie...'.	self assert: currentState class equals: NormalRootState.! !!SearchTests methodsFor: 'tests'!testDefaultSearchNonExistingFilm	|window currentState|	self setUpConnection.	window := self initNormalRoot.	currentState := window state.	currentState inputText: 'nonexistingid'.	self assert: window state class equals: ViewFilmState.	self assert: window state class currentFilm equals: (AbstractFilm empty)! !NormalUserStatesTests subclass: #ViewFilmTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka-Tests'!!ViewFilmTests methodsFor: 'tests'!testViewFilm	| currentState window |	self setUpConnection.	window := self initNormalRoot.	currentState := window state.	currentState screen setSelectedIndex: 1.	currentState buttonViewFilm performAction.	self assert: window state class equals: ViewFilmState.	self assert: window state class currentFilm equals: (RealFilm selectOne: [ :aFilm | aFilm id = 1 ])! !!ViewFilmTests methodsFor: 'tests' stamp: 'PavelErazim 1/6/2019 12:52'!testButtonReviews	|window |	self setUpConnection.	window := self initNormalRoot.	window state screen setSelectedIndex: 1.	window state buttonViewFilm performAction.	window state buttonReview performAction.	self assert: window state class equals: ReviewsState.	self assert: window state class currentFilm equals: (RealFilm selectOne: [ :aFilm | aFilm id = 1 ])! !!ViewFilmTests methodsFor: 'tests'!testViewNotSelectedFilm	| currentState window |	self setUpConnection.	window := self initNormalRoot.	currentState := window state.	currentState buttonViewFilm performAction.	self assert: window state class equals: ViewFilmState.	self assert: window state class currentFilm equals: AbstractFilm empty! !!ViewFilmTests methodsFor: 'tests'!testReturnToDatabase	| currentState window |	self setUpConnection.	window := self initNormalRoot.	window state screen setSelectedIndex: 1.	window state buttonViewFilm performAction.	currentState := window state.	self assert: currentState class equals: ViewFilmState.	currentState buttonReturn performAction.	self assert: window state class equals: NormalRootState! !Object subclass: #AbstractFilm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!AbstractFilm commentStamp: 'MiroslavKalal 1/6/2019 14:36' prior: 0!I'm an abstract class for films.I have following subclasses:EmptyFilmRealFilmfor more info about subclasses see their comments.!!AbstractFilm methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addReview: aReview	self subclassResponsibility ! !!AbstractFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!singleData	self subclassResponsibility ! !!AbstractFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!reviewsData	self subclassResponsibility ! !!AbstractFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!director	self subclassResponsibility ! !!AbstractFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!reviews	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AbstractFilm class	instanceVariableNames: ''!!AbstractFilm class methodsFor: 'requirements' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!empty 	^ EmptyFilm instance! !AbstractFilm subclass: #EmptyFilm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!EmptyFilm commentStamp: 'MiroslavKalal 1/6/2019 14:41' prior: 0!I'm a class repressenting an empty instance of a film.I also use a NULL OBJECT PATTERN. And I am a singleton.My methods define what to return when no movie is selected. I throw custom error when the director message is sent to me, otherwise I return collections with text, stating that there is no film or an empty film cannot have a review.!!EmptyFilm methodsFor: 'accessing'!singleData	^ OrderedCollection new		add: 'No film has been found.';		yourself! !!EmptyFilm methodsFor: 'accessing'!reviewsData	^ OrderedCollection new		add: 'No review for the empty film.';		yourself! !!EmptyFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!director	ShowDirectorError signal! !!EmptyFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!reviews	^ OrderedCollection new.! !!EmptyFilm methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addReview: aReview! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmptyFilm class	instanceVariableNames: 'instance'!!EmptyFilm class methodsFor: 'instance creation' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!new	self error: 'cannot create instance of singleton'! !!EmptyFilm class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!instance	^ 	instance ifNil: [ instance := self basicNew initialize ]! !Error subclass: #FilmDatabaseErrors	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!FilmDatabaseErrors commentStamp: 'MiroslavKalal 1/6/2019 14:43' prior: 0!I am an abstract class for film errors.When some serious error occurs, a corresponding instance of me is thrown.I have a following API:message - returns an error message of what happened !!FilmDatabaseErrors methodsFor: 'accessing'!message	^ self subclassResponsibility ! !FilmDatabaseErrors subclass: #AddObjectWithMissingValuesError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!AddObjectWithMissingValuesError commentStamp: 'PavelErazim 1/5/2019 14:27' prior: 0!I am an error, which is thrown when admin tries to create an object and doesn't have all fields filled.!!AddObjectWithMissingValuesError methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!message	^ 'Cannot create new record when all fields are not filled!! Please, fill all fields.'! !ComposableModel subclass: #FilmDatabaseWindow	instanceVariableNames: 'state user'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!FilmDatabaseWindow commentStamp: 'MiroslavKalal 1/6/2019 14:42' prior: 0!I am a class representing  a GUI(window) client accessing a database of films.I remember a logged 'user'  and a 'state'  I'm in (see StateClass for more details) .I can initialize a database as well as connect to existing one, all with GUI.!!FilmDatabaseWindow methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!state: aState	state := aState withContext: self.! !!FilmDatabaseWindow methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!state	^ state! !!FilmDatabaseWindow methodsFor: 'initialization'!initializeWidgets	state := self class state withContext: self.! !!FilmDatabaseWindow methodsFor: 'initialization'!dynamicChange: aStateClass	self state: aStateClass.	self needRebuild: false.	self buildWithSpecLayout: self class defaultSpec! !!FilmDatabaseWindow methodsFor: 'api' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!title	^ 'Film Database'! !!FilmDatabaseWindow methodsFor: 'api' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!extent	^ 500@500! !!FilmDatabaseWindow methodsFor: 'api' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!user 	^ user! !!FilmDatabaseWindow methodsFor: 'api' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!user: aUser	user := aUser! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FilmDatabaseWindow class	instanceVariableNames: 'state'!!FilmDatabaseWindow class methodsFor: 'installation' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!CleanAllRecords	RealFilm removeAll.	User removeAll.	Actor removeAll.	Director removeAll! !!FilmDatabaseWindow class methodsFor: 'installation' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!exampleTestStart	RealFilm setUpTestConnection.	self CleanAllRecords.	RealFilm ExamplesForTesting.	self new openWithSpec! !!FilmDatabaseWindow class methodsFor: 'installation' stamp: 'PavelErazim 1/5/2019 21:34'!exampleDatabaseReturn	RealFilm setUpConnection.	self new openWithSpec! !!FilmDatabaseWindow class methodsFor: 'installation' stamp: 'PavelErazim 1/5/2019 21:34'!exampleCleanAndInit	RealFilm setUpConnection.	self CleanAllRecords.	RealFilm Examples1.	self new openWithSpec! !!FilmDatabaseWindow class methodsFor: 'specs'!defaultSpec	<spec: #default>	^ SpecLayout composed		add: #state;		yourself! !!FilmDatabaseWindow class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!state: aState	state := aState! !!FilmDatabaseWindow class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!state	^ state! !!FilmDatabaseWindow class methodsFor: 'instance creation' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!new: aState	state := aState.	^ self basicNew initialize! !!FilmDatabaseWindow class methodsFor: 'instance creation' stamp: 'PavelErazim 1/5/2019 21:09'!new	state := LogInState.	^ self basicNew initialize! !Object subclass: #Person	instanceVariableNames: 'id firstName surname born'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!Person commentStamp: 'MiroslavKalal 1/3/2019 16:43' prior: 0!I'm a class representing a person with full name and the date of its birth. I also have a unique identifier to distinguish between two persons with same names.!!Person methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!born	^ born! !!Person methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!id: aNumber	id := aNumber. ! !!Person methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!id	^ id! !!Person methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!firstName	^ firstName ! !!Person methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!firstName: aName	firstName := aName ! !!Person methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!surname	^ surname ! !!Person methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!born: aNumber	born := aNumber! !!Person methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!surname: aName	surname := aName 	! !Person subclass: #Actor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!Actor commentStamp: 'MiroslavKalal 1/3/2019 16:19' prior: 0!I represent a film actor.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Actor class	instanceVariableNames: ''!!Actor class methodsFor: 'testing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!isVoyageRoot	^ true! !Person subclass: #Director	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!Director commentStamp: 'MiroslavKalal 1/6/2019 14:47' prior: 0!I represent a film director.I can be printed, so I provide a useful info about my instance.!!Director methodsFor: 'accessing'!directorData	| data |	data := OrderedCollection new.	data add: 'Born: ' , born greaseString.	data add: 'FirstName: ' , firstName.	data add: 'SurName: ' , surname.	data add: 'Films: '.	(RealFilm selectAll select: [ : each | each director id = id ]) 		do: [ :each | data add: Character tab asString, each name asString, ', ID = ', each id asString].	^ data! !!Director methodsFor: 'printing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!printOn: aStream	aStream		nextPutAll:			firstName asString , ' ' , surname asString , ', ' , born asString				, ', ID = ';		nextPutAll: id asString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Director class	instanceVariableNames: ''!!Director class methodsFor: 'testing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!isVoyageRoot	^ true! !AbstractFilm subclass: #RealFilm	instanceVariableNames: 'id name director genre reviews actors'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!RealFilm commentStamp: 'MiroslavKalal 1/6/2019 14:41' prior: 0!I represent a film.I have a name, a director and genre. It is possible to give me reviews. I can create a database with some examples of stored data for testing and development purposes and setup a database connection for you, like this:RealFilm setUpTestConnection.RealFilm ExamplesForTesting.!!RealFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!director: aString	director := aString ! !!RealFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!genre	^genre! !!RealFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!name	^ name! !!RealFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!actors	^actors! !!RealFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!singleData	|data|	data := OrderedCollection new.	data add: 'ID: ' , self id greaseString.	data add: 'Name: ' , self name.	data add: 'Director: ' , self director firstName, ' ',self director surname.	data add: 'Genre: ' , self genre asString.	data add: 'Actors: '.	actors do: [ :each | data add: Character tab asString, each firstName asString, ' ',		 each surname asString  ].	^data! !!RealFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!name: aString	name := aString ! !!RealFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!reviews 	^reviews! !!RealFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!id 	^ id! !!RealFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!reviewsData	| data |	data := OrderedCollection new.	reviews isEmpty ifTrue: [ ^ data add: 'No review has been found.'; yourself.].	reviews do: [ :each | data add: each ].	^ data! !!RealFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!id: aNumber	id := aNumber! !!RealFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!director	^ director! !!RealFilm methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!genre: aGenre	genre := aGenre! !!RealFilm methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initialize	super initialize.	reviews := OrderedCollection new.	actors := Set new! !!RealFilm methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addReview: aReview	reviews add: aReview! !!RealFilm methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addActor: anActor	actors add: anActor! !!RealFilm methodsFor: 'printing' stamp: 'PavelErazim 1/6/2019 01:18'!printInfo	^ 'a movie - "', name, '"'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RealFilm class	instanceVariableNames: 'currentRepository'!!RealFilm class methodsFor: 'initialization'!setUpConnection	currentRepository := VOMongoRepository		host: 'localhost'		database: 'Films'.	currentRepository enableSingleton! !!RealFilm class methodsFor: 'testing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!isVoyageRoot	^ true! !!RealFilm class methodsFor: 'example data' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!Examples1|Director1 Director2 adminUser normalUser Actor1|adminUser := AdminUser withNick: 'admin'  withPassword: 'admin'.adminUser save.normalUser := NormalUser withNick: 'test' withPassword: '123'.normalUser save.Director1 := Director new id: 1; firstName: 'Adam'; surname: 'Novak'; born: 1990.Director2 := Director new id: 2; firstName: 'Lukas'; surname: 'Tomek'; born: 1800.Actor1 := Actor new id: 1; firstName: 'Tom'; surname: 'Hanks'; born: 1956; save.RealFilm new	id: 1;	director: Director1 ;	name: 'Celisti';	genre: #thriller;	addActor: Actor1 ;	save.RealFilm new	id: 2;	director: Director1 ;	name: 'Vriskot';	genre: #horror;	save.RealFilm new	id: 3;	director: Director2 ;	name: 'Kruh';	genre: #horror;	save.RealFilm new	id: 4;	director: Director1 ;	name: 'Pelisky';	genre: #comedy;	save.! !!RealFilm class methodsFor: 'example data' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!ExamplesForTesting	| adminUser user director actor film |	adminUser := AdminUser withNick: 'admin' withPassword: 'admin'.	user := NormalUser withNick: 'normal' withPassword: 'normal'.	adminUser save.	user save.	director := Director new		id: 1;		firstName: 'Test';		surname: 'Director';		born: 1000.	director save.	actor := Actor new		id: 1;		firstName: 'Test';		surname: 'Actor';		born: 1000.	actor save.	film := RealFilm new		id: 1;		name: 'TestFilm';		director: director;		genre: #horror;		addReview: '<test> wrote: ...'.	film save! !!RealFilm class methodsFor: 'example data'!setUpTestConnection	currentRepository := VOMemoryRepository new.	currentRepository enableSingleton! !ComposableModel subclass: #SearchButton	instanceVariableNames: 'byID byGenre actionBlock inputField'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!SearchButton commentStamp: 'MiroslavKalal 1/6/2019 14:47' prior: 0!I'm a button which starts a search of films in a database based on an id or a film genre specified through a text input.!!SearchButton methodsFor: 'initialization'!initializePresenter	inputField := self class inputField.	byGenre		whenActivatedDo: [			self initializeWidgetsGenre.			self initializePresenter.			inputField				entryCompletion:					(self						entryCompletion: (RealFilm selectAll collect: [ :each | each genre asString ]) asSet asOrderedCollection);				ghostText: 'Type genre of a movie...'.			actionBlock := self genreBlock ].	byID		whenActivatedDo: [ 			self initializeWidgets.			self initializePresenter.			inputField				entryCompletion: nil;				ghostText: 'Type ID of a movie...'.			actionBlock := self idBlock ]! !!SearchButton methodsFor: 'initialization'!initializeWidgetsGenre	|searchButtonGroup|	searchButtonGroup := RadioButtonGroup new.		byID := self newRadioButton.	byID label: 'View by ID'.	searchButtonGroup  addRadioButton: byID.	byGenre := self newRadioButton.	byGenre label: 'Search by Genre'.	searchButtonGroup addRadioButton: byGenre; default: byGenre.! !!SearchButton methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializeWidgets	|searchButtonGroup|	searchButtonGroup := RadioButtonGroup new.		byID := self newRadioButton.	byID label: 'View by ID'.	searchButtonGroup  addRadioButton: byID; default: byID.	byGenre := self newRadioButton.	byGenre label: 'Search by Genre'.	searchButtonGroup addRadioButton: byGenre.! !!SearchButton methodsFor: 'api'!entryCompletion: dataSource	  ^ EntryCompletion new                dataSourceBlock: [ :currText | dataSource ];                filterBlock: [ :currApplicant :currText | 						currApplicant asUppercase includesSubstring: currText asString asUppercase ].! !!SearchButton methodsFor: 'api' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!extent	^160@150! !!SearchButton methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!byID	^byID! !!SearchButton methodsFor: 'accessing'!idBlock	^ [ :aNumber :aWindow | 	| film |	film := RealFilm selectOne: [ :each | each id = aNumber greaseInteger ].	film ifNil: [ film := AbstractFilm empty ].	ViewFilmState currentFilm: film.	aWindow dynamicChange: ViewFilmState ]! !!SearchButton methodsFor: 'accessing'!genreBlock	^ [ :aString :aWindow | 	CollectionState genre: aString asSymbol.	aWindow dynamicChange: CollectionState ]! !!SearchButton methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!actionBlock	^ actionBlock ifNil: [ ^ self idBlock ]! !!SearchButton methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!byGenre	^byGenre! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SearchButton class	instanceVariableNames: 'inputField'!!SearchButton class methodsFor: 'accessing'!inputField	^inputField ! !!SearchButton class methodsFor: 'accessing'!withInputField: anInput	inputField  := anInput! !!SearchButton class methodsFor: 'specs' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultSpec	^ SpecColumnLayout composed	newRow: [:r | r newColumn: [:c | c add: #byID ; add: #byGenre ] ]! !FilmDatabaseErrors subclass: #ShowDirectorError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!ShowDirectorError commentStamp: 'MiroslavKalal 1/6/2019 14:46' prior: 0!Exception that is thrown when user wants to show info about director  and has no film selected.!!ShowDirectorError methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!message	^ 'Cannot show info about director, when no director is selected!!'! !ComposableModel subclass: #StateClass	instanceVariableNames: 'myWindow'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!StateClass commentStamp: 'MiroslavKalal 1/6/2019 14:48' prior: 0!I am an abstract class for States in which a FilmDatabaseWindow can be.I have the following API: * goToErrorState: anError, which is called whenever a custom exception is thrown. An instance of that exception is passed in an argument. See ErrorState for more details.* goToConfirmState: toDelete, which is called when an important decision is to be made, prompts admin if he is sure what he is doing.!!StateClass methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializeWidgets	^ self subclassResponsibility ! !!StateClass methodsFor: 'api'!goToErrorState: anError	myWindow dynamicChange: (ErrorState withError: anError returnTo: self class)! !!StateClass methodsFor: 'api'!goToConfirmState: toRemove	myWindow		dynamicChange: (ConfirmState toDelete: toRemove withReturnTo: self class)! !!StateClass methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!context: aContext	myWindow := aContext.! !!StateClass methodsFor: 'accessing' stamp: 'PavelErazim 1/5/2019 21:48'!genreCollection: aGenre	| data films|	films := RealFilm selectMany: [ :each | each genre = aGenre ].	data := OrderedCollection new.	films do: [:each | data add: 'ID: ' , each id greaseString, ' Name: ' , each name, 		' Director: ' , each director firstName, ' ', each director surname].	data isEmpty ifTrue: [ data add: 'No films fitting genre ''', aGenre asString, '''. Try any of following genres:'.		(RealFilm selectAll collect: [:each | each genre] ) asSet do: [:each | data add: each asString]].	^ data! !!StateClass methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!filmData	| data |	data := OrderedCollection new.	data add: 'list of actors:'.	Actor selectAll do: [ :each | data add: 'ID: ', each id greaseString  ,', Name: ', each firstName, ' ', each surname ].	^ data! !!StateClass methodsFor: 'accessing'!data	^ (RealFilm selectAll asOrderedCollection sort: [ :a :b | a id < b id ]) 		collect: [ :each | 			'ID: ' , each id greaseString , Character tab asString , ',  Name: ' , each name				, Character tab asString , ',  genre: ' , each genre asString ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StateClass class	instanceVariableNames: 'MySecWindow'!!StateClass class methodsFor: 'accessing'!mySecWindow	^ MySecWindow ! !!StateClass class methodsFor: 'special instance creation'!withContext: aContext	MySecWindow := aContext.	^ self new context: aContext ! !StateClass subclass: #AddFilmState	instanceVariableNames: 'buttonReturn buttonAdd screen newFilm inputName inputYear inputDirector inputGenre buttonAddActor'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!AddFilmState commentStamp: 'MiroslavKalal 1/3/2019 16:35' prior: 0!I'm a state class representing the functionality of adding new films to the database. I have GUI comonents to specify the information about a film, to start storing it and to return to the previous state in case the user wishes to leave without or after he stored a new film.!!AddFilmState methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addFilm	newFilm director isNil | newFilm name isNil | newFilm genre isNil		ifTrue: [ AddObjectWithMissingValuesError signal ]		ifFalse: [ newFilm				id: self findID;				save ]! !!AddFilmState methodsFor: 'parsing'!selectedIdOnScreen	| substr |	substr := ', Name\: .*' asRegex copy: screen selectedItem replacingMatchesWith: ''.	^ ('(ID|id)\: ' asRegex copy: substr replacingMatchesWith: '') trimBoth! !!AddFilmState methodsFor: 'parsing'!idFromDirectorInput: input	^ (input copyWithRegex: '.*, .*, ID = ' matchesReplacedWith: '') greaseInteger ! !!AddFilmState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initialize	super initialize.	newFilm := RealFilm new.! !!AddFilmState methodsFor: 'initialization'!initializePresenter	inputName acceptBlock: [ :aString | newFilm name: aString ].	inputDirector		acceptBlock:			[ :anID | |currentID|			currentID := self idFromDirectorInput: anID.			newFilm director: (Director selectOne: [ :each | each id = currentID  			]) ].	inputGenre acceptBlock: [ :aGenre | newFilm genre: aGenre asSymbol ].	buttonReturn		action: [ myWindow dynamicChange: myWindow user defaultAuthenticatedState ].	buttonAdd		action: [ [self addFilm.			myWindow dynamicChange: self class] on: AddObjectWithMissingValuesError do: [ :e | self goToErrorState: e ] ].	buttonAddActor		action: [ 			screen selectedItem isNil ifFalse: [  screen selectedIndex > 1 ifTrue: [ 			newFilm addActor: (Actor selectOne: [:each | each id = self selectedIdOnScreen asNumber]).					]				].			screen items: (self getActorData:(Actor selectAll difference: newFilm actors))			]! !!AddFilmState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializeWidgets	myWindow := self class mySecWindow.	screen := ListModel new.	screen items: self filmData.	buttonReturn := self newButton label: 'Return to database'.	buttonAdd := self newButton label: 'Add film'.	buttonAddActor  := self newButton label: 'Add selected actor'.	inputName := TextInputFieldModel new		ghostText: 'Name';		autoAccept: true;		enabled: true.	inputGenre := TextInputFieldModel new		ghostText: 'Genre';		autoAccept: true;		entryCompletion: (self entryCompletion: 						(RealFilm selectAll collect: [:each | each genre asString]) asSet 															asOrderedCollection );		enabled: true.	inputDirector := TextInputFieldModel new		ghostText: 'Director ID - type and select from menu';		autoAccept: true;		entryCompletion: (self entryCompletion: (Director selectAll collect: [:each | each asString]));		enabled: true! !!AddFilmState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonReturn	^ buttonReturn ! !!AddFilmState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!screen	^ screen! !!AddFilmState methodsFor: 'accessing'!newFilm	^newFilm! !!AddFilmState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!inputName	^ inputName! !!AddFilmState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!inputGenre	^ inputGenre ! !!AddFilmState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!entryCompletion: dataSource	  ^ EntryCompletion new                dataSourceBlock: [ :currText | dataSource ];                filterBlock: [ :currApplicant :currText | 						currApplicant asUppercase includesSubstring: currText asString asUppercase ].! !!AddFilmState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!inputDirector	^ inputDirector ! !!AddFilmState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonAdd	^ buttonAdd! !!AddFilmState methodsFor: 'accessing'!newFilm: aFilm	newFilm := aFilm! !!AddFilmState methodsFor: 'accessing'!getActorData: aCollection	| data |	data := OrderedCollection new.	data add: 'list of actors:'.	aCollection do: [ :each | data add: 'ID: ', each id greaseString  ,', Name: ',each firstName, ' ', each surname ].	data.	^ data! !!AddFilmState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!findID	| currentID |	currentID := RealFilm selectAll size + 1.	[ (RealFilm selectOne: [ :each | each id = currentID ]) isNotNil ]		whileTrue: [ currentID := currentID + 1 ].	^currentID! !!AddFilmState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonAddActor	^ buttonAddActor! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AddFilmState class	instanceVariableNames: ''!!AddFilmState class methodsFor: 'specs' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | column add: #screen; add: #inputName height: 30;			 add: #inputDirector height: 30; add: #inputGenre height: 30]		origin: 0 @ 0 corner: 0.7 @ 1;		newColumn: [ :column | column add: #buttonAddActor; add: #buttonAdd; add: #buttonReturn ]		origin: 0.7 @ 0 corner: 1 @ 1;		yourself! !StateClass subclass: #AddPersonState	instanceVariableNames: 'buttonReturn buttonAdd screen inputName inputSurname inputYear newPerson'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!AddPersonState commentStamp: 'MiroslavKalal 1/6/2019 14:50' prior: 0!I'm a state class for adding persons to the database. I have GUI components for specification of personal data, submitting it and returning to other state.I have following important messages* addPerson - checks if all fields are filled, then calls for addNew, or throws AddObjectWithMissingValuesError.* addNew - abstract message, is called when fields are filled, creates new person according to it's subclass.!!AddPersonState methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addNew	self subclassResponsibility! !!AddPersonState methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addPerson	newPerson firstName isNil | newPerson surname isNil | newPerson born isNil		ifTrue: [ AddObjectWithMissingValuesError signal ]		ifFalse: [ self addNew ]! !!AddPersonState methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addPersonalData	self subclassResponsibility.! !!AddPersonState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!newPerson: aPerson	newPerson := aPerson ! !!AddPersonState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!inputSurname	^ inputSurname! !!AddPersonState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonAdd	^ buttonAdd! !!AddPersonState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonReturn	^ buttonReturn ! !!AddPersonState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!screen	^ screen! !!AddPersonState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!inputYear	^ inputYear! !!AddPersonState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!newPerson	^newPerson ! !!AddPersonState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!inputName	^ inputName! !!AddPersonState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializePresenter	inputName acceptBlock: [ :aString | newPerson firstName: aString ].	inputSurname acceptBlock: [ :aString | newPerson surname: aString ].	inputYear acceptBlock: [ :aYear | newPerson born: aYear greaseInteger ].	buttonReturn action: [ myWindow dynamicChange: AdminRootState ].	buttonAdd		action: [ [ self addPerson.			myWindow dynamicChange: self class ]				on: AddObjectWithMissingValuesError				do: [ :e | self goToErrorState: e ] ]! !!AddPersonState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializeWidgets	myWindow := self class mySecWindow.		screen := ListModel new.	screen items: self addPersonalData.		buttonReturn := self newButton label: 'Return to database'.	buttonAdd := self newButton label: 'Add'.	inputName := TextInputFieldModel new		ghostText: 'First Name';		autoAccept: true;		enabled: true.	inputSurname := TextInputFieldModel new		ghostText: 'Surname';		autoAccept: true;		enabled: true.	inputYear := TextInputFieldModel new		ghostText: 'Birth Year';		autoAccept: true;		enabled: true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AddPersonState class	instanceVariableNames: ''!!AddPersonState class methodsFor: 'specs' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | column add: #screen; add: #inputName height: 30; 			add: #inputSurname height: 30; add: #inputYear height: 30 ]		origin: 0 @ 0 corner: 0.7 @ 1;		newColumn: [ :column | column add: #buttonAdd; add: #buttonReturn ]		origin: 0.7 @ 0 corner: 1 @ 1;		yourself! !AddPersonState subclass: #AddActorState	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!AddActorState commentStamp: 'MiroslavKalal 1/3/2019 16:47' prior: 0!I'm a state class for adding a film actor. I'm a child of the AddPersonState class.!!AddActorState methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addNew	newPerson id: Actor selectAll size + 1.	newPerson save ! !!AddActorState methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addPerson	super addPerson! !!AddActorState methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addPersonalData	|data|	data := self filmData.	^data! !!AddActorState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initialize	super initialize.	newPerson := Actor new! !AddPersonState subclass: #AddDirectorState	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!AddDirectorState commentStamp: 'MiroslavKalal 1/3/2019 16:47' prior: 0!I'm a state class for adding a film director. I'm a child of the AddPersonState class.!!AddDirectorState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initialize	super initialize.	newPerson  := Director new! !!AddDirectorState methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addNew	newPerson id: Director selectAll size + 1.	newPerson save! !!AddDirectorState methodsFor: 'adding' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!addPerson	super addPerson! !!AddDirectorState methodsFor: 'adding'!addPersonalData	|data|	data := self getDirectorData.	^data! !!AddDirectorState methodsFor: 'accessing'!getDirectorData	| data |	data := OrderedCollection new.	data add: 'list of Directors:'.	Director selectAll do: [ :each | data add: 'ID: ', each id greaseString  ,', Name: ',each firstName, ' ', each surname ].	data.	^ data! !StateClass subclass: #AuthenticationState	instanceVariableNames: 'statusField buttonSignUp login inputLogin inputPassword password'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!AuthenticationState commentStamp: 'PavelErazim 1/5/2019 21:54' prior: 0!I am a a State of user authentication.I have following subclasses:* LogInState* SignUpStatefor more details, see corresponding subclass.!!AuthenticationState methodsFor: 'accessing'!loginPassed: aLogin	login := aLogin! !!AuthenticationState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!password	^password! !!AuthenticationState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonSignUp	^ buttonSignUp! !!AuthenticationState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!inputLogin	^inputLogin! !!AuthenticationState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!inputPassword	^inputPassword ! !!AuthenticationState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!login	^login! !!AuthenticationState methodsFor: 'accessing'!statusField	^ statusField! !!AuthenticationState methodsFor: 'accessing'!statusField: aField	statusField := aField ! !!AuthenticationState methodsFor: 'accessing'!passwordPassed: aPassword	password := aPassword ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AuthenticationState class	instanceVariableNames: 'wrongCredentials'!!AuthenticationState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!wrongCredentials: aBoolean	wrongCredentials := aBoolean! !!AuthenticationState class methodsFor: 'accessing'!wrongCredentials	^ wrongCredentials ! !StateClass subclass: #CollectionState	instanceVariableNames: 'buttonReturn input screen'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!CollectionState commentStamp: 'MiroslavKalal 1/6/2019 14:54' prior: 0!I'm a state class representing a film collection of the same genre, when someone uses "Search by genre" feature, available in RootState.!!CollectionState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!inputText: aString	self class genre: aString asSymbol.! !!CollectionState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonReturn	^ buttonReturn ! !!CollectionState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!input 	^ input! !!CollectionState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!screen 	^ screen ! !!CollectionState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializePresenter	buttonReturn action: [ myWindow dynamicChange: myWindow user defaultAuthenticatedState ].	input		acceptBlock: [ :aNumber | 			self inputText: aNumber.			myWindow dynamicChange: CollectionState ]! !!CollectionState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializeWidgets	myWindow := self class mySecWindow.	screen := ListModel new.	screen items:  (self genreCollection: self class genre).	buttonReturn := self newButton label: 'Return to database'.	input := TextInputFieldModel new		ghostText: 'Type your prefered genre:';		enabled: true.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CollectionState class	instanceVariableNames: 'genre'!!CollectionState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!genre: aGenre	genre := aGenre! !!CollectionState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!genre	^genre! !!CollectionState class methodsFor: 'specs' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | column add: #screen; add: #input height: 30 ]		origin: 0 @ 0 corner: 0.7 @ 1;		newColumn: [ :column | column add: #buttonReturn]		origin: 0.7 @ 0 corner: 1 @ 1;		yourself! !StateClass subclass: #ConfirmState	instanceVariableNames: 'buttonYes buttonNo text'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!ConfirmState commentStamp: 'MiroslavKalal 1/6/2019 14:55' prior: 0!I represent a state where AdminUser ends up when he wants to delete something which may be important. I have a GUI with two buttons:* buttonYes - deletes selected object and returns to previous state* buttonNo - doesn't delete the selected object and returns the user to previous state!!ConfirmState methodsFor: 'initialization' stamp: 'PavelErazim 1/5/2019 23:37'!initializePresenter	buttonYes action: [ self class toDelete remove. myWindow dynamicChange: self class returnTo ].	buttonNo action: [ myWindow dynamicChange: self class returnTo  ].! !!ConfirmState methodsFor: 'initialization' stamp: 'PavelErazim 1/6/2019 01:16'!initializeWidgets	text := TextModel new text: 'Are you sure you want to delete ', self class toDelete printInfo, '?'; disable.	myWindow := self class mySecWindow.	buttonYes := self newButton label: 'Yes'.	buttonNo := self newButton label: 'No'.! !!ConfirmState methodsFor: 'accessing' stamp: 'PavelErazim 1/5/2019 22:55'!buttonNo	^ buttonNo! !!ConfirmState methodsFor: 'accessing' stamp: 'PavelErazim 1/5/2019 23:54'!text	^ text! !!ConfirmState methodsFor: 'accessing' stamp: 'PavelErazim 1/5/2019 22:55'!buttonYes	^ buttonYes! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ConfirmState class	instanceVariableNames: 'returnTo toDelete'!!ConfirmState class methodsFor: 'accessing' stamp: 'PavelErazim 1/5/2019 22:46'!returnTo	^returnTo! !!ConfirmState class methodsFor: 'accessing' stamp: 'PavelErazim 1/5/2019 23:05'!toDelete	^ toDelete! !!ConfirmState class methodsFor: 'accessing' stamp: 'PavelErazim 1/5/2019 23:15'!toDelete: anObject withReturnTo: aState	returnTo := aState.	toDelete := anObject! !!ConfirmState class methodsFor: 'specs'!defaultSpec	<spec: #default>	^ SpecRowLayout composed		newColumn: [ :column | column 	newRow: [:row | row add: #text] origin: 0 @ 0 corner: 0.3 @ 1;newRow: [:row | row newColumn: [:column1| column1 add: #buttonYes]; newColumn: [:column2| column2 add: #buttonNo] ] origin: 0.5 @ 0 corner: 0.8 @ 1]	! !StateClass subclass: #DirectorState	instanceVariableNames: 'buttonReturn screen'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!DirectorState commentStamp: 'MiroslavKalal 1/6/2019 15:10' prior: 0!I'm a state representing director data, such as his name, birth year and films of his.I am available when a user viewing a film uses "Show director info" feature - available in ViewFilmState.!!DirectorState methodsFor: 'initialization'!initializePresenter	buttonReturn action: [ myWindow dynamicChange: ViewFilmState ].! !!DirectorState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializeWidgets	myWindow := self class mySecWindow.	screen := ListModel new.	screen items:  self class director directorData.	buttonReturn := self newButton label: 'Return to movie'.! !!DirectorState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonReturn	^ buttonReturn! !!DirectorState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!screen	^ screen ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DirectorState class	instanceVariableNames: 'director'!!DirectorState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!director: aDirector	director := aDirector ! !!DirectorState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!director 	^ director ! !!DirectorState class methodsFor: 'specs' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | column add: #screen]		origin: 0 @ 0 corner: 0.7 @ 1;		newColumn: [ :column | column add: #buttonReturn ]		origin: 0.7 @ 0 corner: 1 @ 1;		yourself! !StateClass subclass: #ErrorState	instanceVariableNames: 'message errorReceived returnTo errorMessage buttonReturn'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!ErrorState commentStamp: 'MiroslavKalal 1/6/2019 15:10' prior: 0!I am a state where a user ends up when he invokes a MovieDatabaseError (an exception). I remember an instance of error which brought the user here, and display its message. I also remeber a state from which the user got here so he can return where he was.My methods:* errorReceived - returns an instance of error which was thrown and brought the user here - see FilmDatabaseErrors class for more info.!!ErrorState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonReturn	^buttonReturn! !!ErrorState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!errorMessage	^errorMessage! !!ErrorState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!errorReceived	^ errorReceived! !!ErrorState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializePresenter	buttonReturn action: [ myWindow dynamicChange: self class returnTo ].! !!ErrorState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializeWidgets	myWindow := self class mySecWindow.	errorReceived := self class errorReceived.	errorMessage := TextModel new text: errorReceived message; disable.	buttonReturn := self newButton label: 'Return'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ErrorState class	instanceVariableNames: 'returnTo errorReceived'!!ErrorState class methodsFor: 'specs' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | column add: #errorMessage]		origin: 0 @ 0 corner: 0.7 @ 1;		newColumn: [ :column | column add: #buttonReturn ]		origin: 0.7 @ 0 corner: 1 @ 1;		yourself! !!ErrorState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!errorReceived	^ errorReceived! !!ErrorState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!returnTo	^returnTo! !!ErrorState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!withError: anError returnTo: aState	errorReceived := anError.	returnTo := aState! !AuthenticationState subclass: #LogInState	instanceVariableNames: 'buttonLogInAuth'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!LogInState commentStamp: 'MiroslavKalal 1/6/2019 14:53' prior: 0!I'm a state class where user starts at when connecting to the database.After authenticating, a state will be selected according to the authenticated user's role:AdminRootState for AdminUser.NormalRootState for NormalUser.!!LogInState methodsFor: 'accessing'!buttonLogInAuth	^ buttonLogInAuth! !!LogInState methodsFor: 'initialization'!initializePresenter	inputLogin acceptBlock: [ :aLogin | self loginPassed: aLogin asString].	inputPassword  acceptBlock: [ :aPassword | self passwordPassed: aPassword asString].	buttonLogInAuth action: [ self logInAuth ].	buttonSignUp action: [ myWindow dynamicChange: SignUpState ]! !!LogInState methodsFor: 'initialization'!initializeWidgets	myWindow := self class mySecWindow.	buttonLogInAuth := self newButton label: 'Log in'.	inputLogin := TextInputFieldModel new		ghostText: 'login (type: admin or test)';		autoAccept: true;		enabled: true.	inputPassword := TextInputFieldModel new		ghostText: 'password (type: admin or 123)';		autoAccept: true;		encrypted: true;		enabled: true.	statusField := TextModel new		text: 'Enter your credentials';		disable.	buttonSignUp := self newButton label: 'Sign Up'.	self class wrongCredentials ifNotNil: [ 		self class wrongCredentials ifTrue: [ statusField text: 'Wrong credentials!!!!!!'] ]! !!LogInState methodsFor: 'api'!logInAuth	| user |	user := User selectOne: [ :each | each nick = login & (each password = password) ].	user		ifNil: [ self class wrongCredentials: true.			myWindow dynamicChange: self class.			self class wrongCredentials: false ]		ifNotNil: [ myWindow user: user.			myWindow dynamicChange: user defaultAuthenticatedState ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LogInState class	instanceVariableNames: ''!!LogInState class methodsFor: 'specs'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | 			column				add: #statusField height: 40;				add: #inputLogin height: 40;				add: #inputPassword height: 40;				add: #buttonLogInAuth height: 40;				add: #buttonSignUp height: 40 ]			origin: 0.25 @ 0.3			corner: 0.75 @ 0.75;		yourself! !StateClass subclass: #ManageReviewState	instanceVariableNames: 'buttonReturn buttonDelete screen'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!ManageReviewState commentStamp: 'MiroslavKalal 1/6/2019 14:59' prior: 0!I'm a state class for deleting an existing review. I'm available only for AdminUsers.  An admin user can delete selected review using my butttonDelete.!!ManageReviewState methodsFor: 'initialization'!initializePresenter	buttonDelete		action:			[			  (self class currentFilm reviews isNotEmpty & screen selectedItem isNotNil ) ifTrue: [				 self class currentFilm reviews removeAt: screen selectedIndex.				 self class currentFilm save.				 screen items: self class currentFilm reviewsData				].					].	buttonReturn		action:			[ myWindow dynamicChange: ViewFilmState ]! !!ManageReviewState methodsFor: 'initialization'!initializeWidgets	myWindow := self class mySecWindow.	screen := ListModel new.	self class currentFilm ifNil: [ self class currentFilm: AbstractFilm empty ].	screen items: self class currentFilm reviewsData.	buttonReturn := self newButton label: 'Return to movie'.	buttonDelete := self newButton label: 'Delete selected comment'.! !!ManageReviewState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonReturn	^ buttonReturn! !!ManageReviewState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!screen	^screen! !!ManageReviewState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonDelete	^buttonDelete ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManageReviewState class	instanceVariableNames: 'currentFilm'!!ManageReviewState class methodsFor: 'specs' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | column add: #screen ]		origin: 0 @ 0 corner: 0.7 @ 1;		newColumn: [ :column | column add: #buttonReturn; add: #buttonDelete]		origin: 0.7 @ 0 corner: 1 @ 1;		yourself! !!ManageReviewState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!currentFilm	^currentFilm! !!ManageReviewState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!currentFilm: anObject	currentFilm := anObject! !StateClass subclass: #ManageUsersState	instanceVariableNames: 'buttonReturn buttonDelete screen buttonChangeRole'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!ManageUsersState commentStamp: 'MiroslavKalal 1/6/2019 15:11' prior: 0!I'm a state class for deleting existing users. I'm available only for AdminUsers. An admin user can delete a selected user using my butttonDelete. The admin cannot delete himself from database (he can't even see his nickname in the list).An admin can also change a role of a selected user, always switching from NormalUser to AdminUser and vice versa.!!ManageUsersState methodsFor: 'initialization' stamp: 'PavelErazim 1/5/2019 23:09'!initializePresenter	buttonDelete		action: [ screen selectedItem isNotNil				ifTrue: [ self goToConfirmState: (User selectOne: [ :each | each nick = self selectedNickOnScreen ]) ].			screen items: self userData ].	buttonChangeRole		action: [ | newRole oldRole |			screen selectedItem isNotNil				ifTrue: [ oldRole := User selectOne: [ :each | each nick = self selectedNickOnScreen ].					newRole := oldRole changeRole.					oldRole remove.					newRole save ].			screen items: self userData ].	buttonReturn action: [ myWindow dynamicChange: AdminRootState ]! !!ManageUsersState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializeWidgets	myWindow := self class mySecWindow.	screen := ListModel new.	screen items: self userData.	buttonReturn := self newButton label: 'Return to database'.	buttonDelete := self newButton label: 'Delete selected user'.	buttonChangeRole := self newButton label: 'Change user''s role'! !!ManageUsersState methodsFor: 'accessing'!userData	^ ((User selectAll select: [ :each | each nick ~= myWindow user nick ]) asOrderedCollection 		sort: [ :a :b | a nick < b nick ]) collect: [ :each | each asString , ': ' , each nick ]! !!ManageUsersState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonReturn	^buttonReturn ! !!ManageUsersState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!selectedNickOnScreen	^ screen selectedItem copyWithRegex: '.*\: ' matchesReplacedWith: ''! !!ManageUsersState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!screen	^screen! !!ManageUsersState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonChangeRole	^buttonChangeRole! !!ManageUsersState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonDelete	^buttonDelete! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManageUsersState class	instanceVariableNames: ''!!ManageUsersState class commentStamp: 'MiroslavKalal 1/6/2019 15:11' prior: 0!I'm a state class for deleting existing users. I'm available only for AdminUsers. An admin user can delete a selected user using my butttonDelete. The admin cannot delete himself from database (he can't even see his nickname in the list).An admin can also change a role of a selected user, always switching from NormalUser to AdminUser and vice versa.!!ManageUsersState class methodsFor: 'specs'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | column add: #screen ] origin: 0 @ 0 corner: 0.7 @ 1;		newColumn: [ :column | 			column				add: #buttonReturn;				add: #buttonDelete;				add: #buttonChangeRole ]			origin: 0.7 @ 0			corner: 1 @ 1;		yourself! !StateClass subclass: #ReviewsState	instanceVariableNames: 'buttonReturn input screen currentFilm'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!ReviewsState commentStamp: 'PavelErazim 1/6/2019 12:57' prior: 0!I'm a state class for adding film reviews. I need to remember a film (currentFilm), so I know to which one will the new review belong to. I have GUI components for writing and submitting a single review and a return button to return to a state where is the selected film's description (ViewMovieState).!!ReviewsState methodsFor: 'initialization'!initializePresenter	input		acceptBlock: [ :anInput | 			ViewFilmState currentFilm				addReview: myWindow user nick asString , ' wrote: <' , anInput asString , '>';				save.			myWindow dynamicChange: self class ].	buttonReturn action: [ myWindow dynamicChange: ViewFilmState ]! !!ReviewsState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializeWidgets	myWindow := self class mySecWindow.	screen := ListModel new.	screen items: self class currentFilm reviewsData.	buttonReturn := self newButton label: 'Return to movie'.	input := TextInputFieldModel new		ghostText: 'Write your review:';		enabled: true.! !!ReviewsState methodsFor: 'accessing'!buttonReturn	^ buttonReturn! !!ReviewsState methodsFor: 'accessing'!input 	^input! !!ReviewsState methodsFor: 'accessing'!screen	^ screen ! !!ReviewsState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!currentFilm: anObject	currentFilm := anObject! !!ReviewsState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!currentFilm	^ currentFilm! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReviewsState class	instanceVariableNames: 'currentFilm'!!ReviewsState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!currentFilm	^ currentFilm! !!ReviewsState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!currentFilm: anObject	currentFilm := anObject! !!ReviewsState class methodsFor: 'specs' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | column add: #screen; add: #input height: 30 ]		origin: 0 @ 0 corner: 0.7 @ 1;		newColumn: [ :column | column add: #buttonReturn ]		origin: 0.7 @ 0 corner: 1 @ 1;		yourself! !StateClass subclass: #RootState	instanceVariableNames: 'buttonSearch buttonSignOut input screen'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!RootState commentStamp: 'MiroslavKalal 1/6/2019 15:01' prior: 0!I am a class of RootState, available after user logs in. My subclasses are called according to user's role.See AdminRootState or NormalRootState for more details.!!RootState methodsFor: 'initialization'!initializeRootPresenter	input acceptBlock: [ :aNumber | self inputText: aNumber ].	input whenGhostTextChanged: [  myWindow  needRebuild: false.	myWindow buildWithSpecLayout: myWindow class defaultSpec  ].	buttonSignOut		action: [ myWindow dynamicChange: LogInState.			myWindow user: User new ]! !!RootState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!inputText: aNumber	self buttonSearch actionBlock value: aNumber value: myWindow ! !!RootState methodsFor: 'initialization' stamp: 'PavelErazim 1/6/2019 13:25'!initializeRootWidgets	myWindow := self class mySecWindow.	screen := ListModel new.	screen items: self data.	buttonSignOut := self newButton label: 'Sign Out (' , myWindow user nick , ')'.	input := TextInputFieldModel new		ghostText: 'Type ID of a movie ...';		enabled: true.	buttonSearch := self instantiate: (SearchButton withInputField: input)! !!RootState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonSearch	^ buttonSearch! !!RootState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!screen	^ screen! !!RootState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonSignOut	^ buttonSignOut! !!RootState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!input	^ input! !RootState subclass: #AdminRootState	instanceVariableNames: 'buttonAddDirector buttonAddActor buttonAddFilm buttonRemove buttonUsers'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!AdminRootState commentStamp: 'MiroslavKalal 1/6/2019 15:07' prior: 0!State where user ends up when logging as admin. Here an AdminUser can manage films, actors, directors, users and reviews. !!AdminRootState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonAddFilm	^ buttonAddFilm ! !!AdminRootState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonUsers	^ buttonUsers! !!AdminRootState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonAddActor	^ buttonAddActor  ! !!AdminRootState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonAddDirector	^ buttonAddDirector  ! !!AdminRootState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonRemove	^ buttonRemove  ! !!AdminRootState methodsFor: 'initialization' stamp: 'PavelErazim 1/6/2019 00:54'!initializePresenter	self initializeRootPresenter.	buttonAddFilm action: [ myWindow dynamicChange: AddFilmState ].	buttonUsers action: [ myWindow dynamicChange: ManageUsersState ].	buttonAddDirector action: [ myWindow dynamicChange: AddDirectorState ].	buttonRemove action: [ (screen selectedItem isNotNil ) ifTrue: [				self goToConfirmState: (RealFilm selectOne: [ :each | each id = self selectedFilmOnScreen ]).				].			  screen items: self data].	buttonAddActor action: [ myWindow dynamicChange: AddActorState ].! !!AdminRootState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializeWidgets	self initializeRootWidgets.	buttonAddActor := self newButton label: 'Add Actor'.	buttonAddDirector := self newButton label: 'Add Director'.	buttonAddFilm := self newButton label: 'Add Film'.	buttonRemove := self newButton label: 'Remove Film'.	buttonUsers := self newButton label: 'Manage users'! !!AdminRootState methodsFor: 'printing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!print: aString	| prev |	prev := self data.	prev add: aString.	screen items: prev! !!AdminRootState methodsFor: 'printing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!selectedFilmOnScreen	^ (screen selectedItem copyWithRegex: '(ID\: |, Name\:.*)' matchesReplacedWith: '') greaseInteger 	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AdminRootState class	instanceVariableNames: ''!!AdminRootState class methodsFor: 'specs' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | column newRow: 													[:row | row add: #buttonUsers;																	add: #buttonRemove] height: 60;									         add: #screen; add: #input height: 30 ]		origin: 0 @ 0 corner: 0.7 @ 1;		newColumn: [ :column | column add: #buttonAddFilm; add: #buttonAddActor; add: #buttonAddDirector; add: #buttonSearch ; add: #buttonSignOut ]		origin: 0.7 @ 0 corner: 1 @ 1;		yourself		! !RootState subclass: #NormalRootState	instanceVariableNames: 'buttonViewFilm'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!NormalRootState commentStamp: 'MiroslavKalal 1/6/2019 15:08' prior: 0!State where a user ends up when logging as normal user.NormalUser can view or search for a film, or leave a comment (review) for a particular selected film.!!NormalRootState methodsFor: 'initialization'!initializePresenter	| id |	self initializeRootPresenter.	buttonViewFilm		action: [ screen selectedItem isNil				ifTrue: [ ViewFilmState currentFilm: AbstractFilm empty ]				ifFalse: [ id := self selectedIdOnScreen asNumber.					ViewFilmState currentFilm: (RealFilm selectOne: [ :aFilm | aFilm id = id ]) ].			myWindow dynamicChange: ViewFilmState ]! !!NormalRootState methodsFor: 'initialization' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!initializeWidgets	self initializeRootWidgets.	buttonViewFilm := self newButton label: 'View the selected film'.! !!NormalRootState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonViewFilm	^ buttonViewFilm! !!NormalRootState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!selectedIdOnScreen	| substr |	substr := ', Name\: .*' asRegex copy: screen selectedItem replacingMatchesWith: ''.	^ ('(ID|id)\: ' asRegex copy: substr replacingMatchesWith: '') trimBoth! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NormalRootState class	instanceVariableNames: ''!!NormalRootState class methodsFor: 'specs' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | 			column				add: #screen;				add: #input height: 30 ]			origin: 0 @ 0			corner: 0.7 @ 1;		newColumn: [ :column | 			column				add: #buttonViewFilm;				add: #buttonSearch;				add: #buttonSignOut ]			origin: 0.7 @ 0			corner: 1 @ 1;		yourself! !AuthenticationState subclass: #SignUpState	instanceVariableNames: 'buttonReturn'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!SignUpState commentStamp: 'PavelErazim 1/5/2019 21:54' prior: 0!I'm a state class for registration of a new user. I can only  add instance of NormalUser that doesn't exist in the database yet.!!SignUpState methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!buttonReturn	^ buttonReturn! !!SignUpState methodsFor: 'initialization' stamp: 'PavelErazim 1/5/2019 21:09'!initializePresenter	inputLogin acceptBlock: [ :aLogin | self loginPassed: aLogin asString].	inputPassword  acceptBlock: [ :aPassword | self passwordPassed: aPassword asString].	buttonReturn action: [ myWindow dynamicChange: LogInState ].	buttonSignUp action: [ self signUp ]! !!SignUpState methodsFor: 'initialization'!initializeWidgets	myWindow := self class mySecWindow.	inputLogin := TextInputFieldModel new		ghostText: 'nickname';		autoAccept: true;		enabled: true.	inputPassword := TextInputFieldModel new		ghostText: 'password';		autoAccept: true;		encrypted: true;		enabled: true.	statusField := TextModel new		text: 'Create new user.';		disable.	buttonSignUp := self newButton label: 'Register new user'.	buttonReturn := self newButton label: 'Return to login'.	self class wrongCredentials		ifNotNil: [ self class wrongCredentials 				ifTrue: [ statusField text: 'You must fill both fields!!' ] ].	self class userAlreadyExists		ifNotNil: [ self class userAlreadyExists				ifTrue: [ statusField text: 'User already exists!!' ] ]! !!SignUpState methodsFor: 'api'!signUp	| user newUser |	password isNil | login isNil		ifTrue: [ self class wrongCredentials: true.			myWindow dynamicChange: self class.			self class wrongCredentials: false ]		ifFalse: [ user := User selectOne: [ :each | each nick = login ].			user				ifNotNil: [ self class userAlreadyExists: true.					myWindow dynamicChange: self class.					self class userAlreadyExists: false ]				ifNil: [ newUser := NormalUser withNick: self login withPassword: self password.					newUser save.					statusField text: 'User succesfully created :-)' ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SignUpState class	instanceVariableNames: 'userAlreadyExists'!!SignUpState class methodsFor: 'specs' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | 			column				add: #statusField height: 40;				add: #inputLogin height: 40;				add: #inputPassword height: 40;				add: #buttonSignUp height: 40;				add: #buttonReturn height: 40 ]			origin: 0.25 @ 0.3			corner: 0.75 @ 0.75;		yourself! !!SignUpState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!userAlreadyExists: aBoolean	userAlreadyExists := aBoolean! !!SignUpState class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!userAlreadyExists	^ userAlreadyExists ! !Object subclass: #User	instanceVariableNames: 'nick password'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!User commentStamp: 'MiroslavKalal 1/6/2019 15:13' prior: 0!User class.Defines a user.A user can have two different roles:- normal (default) - a regular database user, can view and comment movies- admin - an admin can add and edit entries and usersThe user's role can be changed by an AdminUser using ManageUsers feature.How to add a new user:| admin normal |	admin := AdminUser		withNick: 'jarda-OOP'		withPassword: '123myjsmebratri!!'.	normal := NormalUser		withNick: 'mates-OOP'		withPassword: '321aninahodu!!'.!!User methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultAuthenticatedState	self subclassResponsibility! !!User methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!password	^ password! !!User methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!changeRole	self subclassResponsibility ! !!User methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!nick: aNick	nick := aNick.! !!User methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!reviewState	self subclassResponsibility! !!User methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!nick	^ nick! !!User methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!password: aPassword	password := aPassword! !!User methodsFor: 'printing' stamp: 'PavelErazim 1/6/2019 01:09'!printInfo	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!User class	instanceVariableNames: ''!!User class methodsFor: 'instance creation'!withNick: aNick withPassword: aPassword	|user|	user := self new.	user nick: aNick.	user password: aPassword.	^ user! !!User class methodsFor: 'testing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!isVoyageRoot	^true! !User subclass: #AdminUser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!AdminUser commentStamp: 'PavelErazim 1/5/2019 22:05' prior: 0!I'm a class representing a registered administrator.See AdminRootState for more detailed list of AdminUsers features.!!AdminUser methodsFor: 'printing' stamp: 'PavelErazim 1/6/2019 01:14'!printInfo	^ 'an admin user - ', nick! !!AdminUser methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultAuthenticatedState	^ AdminRootState! !!AdminUser methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!changeRole	^ NormalUser withNick: nick withPassword: password.! !!AdminUser methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!reviewState	^ ManageReviewState ! !User subclass: #NormalUser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!NormalUser commentStamp: 'MiroslavKalal 1/6/2019 15:13' prior: 0!I am a class representing a NormalUser.NormalUsers can view a film, add a review or search by genre.NormalUser can be promoted by admin to AdminUser.!!NormalUser methodsFor: 'printing' stamp: 'PavelErazim 1/6/2019 01:14'!printInfo	^ 'a normal user - ', nick! !!NormalUser methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!defaultAuthenticatedState	^ NormalRootState! !!NormalUser methodsFor: 'accessing' stamp: 'CompatibleUserName 1/5/2019 19:56:02'!changeRole	^ AdminUser withNick: nick withPassword: password.! !!NormalUser methodsFor: 'accessing' stamp: 'PavelErazim 1/6/2019 12:52'!reviewState	^ ReviewsState ! !StateClass subclass: #ViewFilmState	instanceVariableNames: 'buttonReturn buttonDirector input screen buttonReview'	classVariableNames: ''	poolDictionaries: ''	category: 'Semestralka'!!ViewFilmState commentStamp: 'MiroslavKalal 1/3/2019 16:52' prior: 0!I'm a state where you can see all the information about a selected film. I have GUI components to add a review (which will set a different state), see the information about the film's director and return to initial state.!!ViewFilmState methodsFor: 'initialization'!initializePresenter	input		acceptBlock: [ :aNumber | 			self inputText: aNumber greaseInteger.			myWindow dynamicChange: self class ].	buttonReturn action: [ myWindow dynamicChange: myWindow user defaultAuthenticatedState ].	buttonDirector		action: [ [DirectorState director: self class currentFilm director. myWindow dynamicChange: DirectorState] on: ShowDirectorError do: [ :e |  self goToErrorState: e ].			  ].	myWindow user reviewState currentFilm: self class currentFilm.	buttonReview action: [ myWindow dynamicChange: myWindow user reviewState ]! !!ViewFilmState methodsFor: 'initialization'!initializeWidgets	myWindow := self class mySecWindow.	screen := ListModel new.	screen items:  (self class currentFilm singleData).	buttonReturn := self newButton label: 'Return to database'.	buttonDirector := self newButton label: 'Show director info'.	buttonReview := self newButton label: 'Reviews'.	input := TextInputFieldModel new		ghostText: 'Type ID of another movie';		enabled: true.! !!ViewFilmState methodsFor: 'accessing'!inputText: aNumber	|aFilm|	aFilm := RealFilm selectOne: [ :each | each id = aNumber ].	aFilm ifNil: [ aFilm := AbstractFilm empty  ].	self class currentFilm: aFilm! !!ViewFilmState methodsFor: 'accessing'!buttonDirector	^ buttonDirector  ! !!ViewFilmState methodsFor: 'accessing'!buttonReturn	^ buttonReturn ! !!ViewFilmState methodsFor: 'accessing'!input 	^ input ! !!ViewFilmState methodsFor: 'accessing'!screen 	^ screen ! !!ViewFilmState methodsFor: 'accessing'!buttonReview	^ buttonReview! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ViewFilmState class	instanceVariableNames: 'currentFilm'!!ViewFilmState class methodsFor: 'accessing'!currentFilm	^ currentFilm! !!ViewFilmState class methodsFor: 'accessing'!currentFilm: aFilm	currentFilm := aFilm! !!ViewFilmState class methodsFor: 'specs'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | column add: #screen; add: #input height: 30 ]		origin: 0 @ 0 corner: 0.7 @ 1;		newColumn: [ :column | column add: #buttonReturn; add: #buttonDirector; add: #buttonReview ]		origin: 0.7 @ 0 corner: 1 @ 1;		yourself! !